// Enhanced PDF Generation Utility with Complete Content Support
import jsPDF from 'jspdf';

export const generatePDF = (pitchContent, options = {}) => {
  try {
    const pdf = new jsPDF('p', 'mm', 'a4');
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 15;
    const usableWidth = pageWidth - (margin * 2);
    const lineHeight = 6;
    const maxCharsPerLine = Math.floor(usableWidth / 2.8); // Approximate character limit per line
    
    // Enhanced text processing function
    const processText = (text) => {
      // Clean up text formatting
      return text
        .replace(/╔═+╗/g, '') // Remove box drawing characters
        .replace(/║/g, '') // Remove vertical box characters
        .replace(/╚═+╝/g, '') // Remove bottom box characters
        .replace(/═+/g, '─'.repeat(50)) // Replace long equals with dashes
        .replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold markdown
        .replace(/\*(.*?)\*/g, '$1') // Remove italic markdown
        .replace(/`(.*?)`/g, '$1') // Remove code backticks
        .replace(/#{1,6}\s*/g, '') // Remove markdown headers
        .replace(/^\s*[-•*]\s*/gm, '• ') // Normalize bullet points
        .replace(/^\s*\d+\.\s*/gm, '• ') // Convert numbered lists to bullets
        .replace(/\n{3,}/g, '\n\n') // Limit multiple newlines
        .trim();
    };

    // Enhanced content parsing
    const parseContent = (content) => {
      const processed = processText(content);
      
      // Try multiple parsing strategies
      let slides = [];
      
      // Strategy 1: Look for SLIDE markers
      if (processed.includes('SLIDE')) {
        slides = processed.split(/(?:SLIDE\s*\d+:|SLIDE\s+\d+\s*[-:])/).filter(s => s.trim());
        // Remove any content before first slide
        if (slides.length > 0 && !slides[0].includes('SLIDE')) {
          slides = slides.slice(1);
        }
      }
      
      // Strategy 2: Look for numbered sections
      else if (processed.match(/^\d+\./m)) {
        slides = processed.split(/(?=^\d+\.)/m).filter(s => s.trim());
      }
      
      // Strategy 3: Look for section headers with dashes or equals
      else if (processed.includes('─') || processed.includes('=')) {
        slides = processed.split(/(?=^.{10,}(?:─+|=+))/m).filter(s => s.trim());
      }
      
      // Strategy 4: Split by multiple newlines (fallback)
      else {
        const sections = processed.split(/\n\n+/).filter(s => s.trim());
        // Group smaller sections together
        slides = [];
        let currentSlide = '';
        
        sections.forEach(section => {
          if (currentSlide.length + section.length < 800) {
            currentSlide += (currentSlide ? '\n\n' : '') + section;
          } else {
            if (currentSlide) slides.push(currentSlide);
            currentSlide = section;
          }
        });
        if (currentSlide) slides.push(currentSlide);
      }
      
      return slides.filter(slide => slide.trim().length > 20); // Filter out very short slides
    };

    // Header setup
    pdf.setFontSize(24);
    pdf.setFont('helvetica', 'bold');
    pdf.setTextColor(34, 139, 34); // Forest green
    pdf.text('Startup Pitch Deck', margin, margin + 15);
    
    // Subtitle and metadata
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'normal');
    pdf.setTextColor(70, 70, 70);
    const timestamp = new Date().toLocaleString();
    pdf.text('Generated by Cofoundr AI', margin, margin + 25);
    pdf.text(`Created: ${timestamp}`, margin, margin + 33);
    
    // Add a separator line
    pdf.setDrawColor(200, 200, 200);
    pdf.line(margin, margin + 40, pageWidth - margin, margin + 40);
    
    let currentY = margin + 50;
    let slideNumber = 1;
    
    // Parse content into slides
    const slides = parseContent(pitchContent);
    
    if (slides.length === 0) {
      // Fallback: treat entire content as one section
      slides.push(processText(pitchContent));
    }

    slides.forEach((slideContent, index) => {
      const trimmedContent = slideContent.trim();
      if (!trimmedContent) return;
      
      // Check if we need a new page
      if (currentY > pageHeight - 60) {
        pdf.addPage();
        currentY = margin + 10;
      }
      
      // Extract slide title (first line or first sentence)
      const lines = trimmedContent.split('\n').filter(line => line.trim());
      let slideTitle = '';
      let contentLines = lines;
      
      if (lines.length > 0) {
        const firstLine = lines[0].trim();
        // Check if first line looks like a title
        if (firstLine.length < 80 && (
          firstLine.match(/^[A-Z\s]+:?$/) || // All caps
          firstLine.includes(':') || // Contains colon
          firstLine.match(/^\d+\./) || // Starts with number
          lines.length > 1 && lines[1].trim() === '' // Followed by empty line
        )) {
          slideTitle = firstLine.replace(/^\d+\.\s*/, '').replace(/:$/, '');
          contentLines = lines.slice(1);
        } else {
          // Generate title from content
          slideTitle = firstLine.split('.')[0].substring(0, 50) + (firstLine.length > 50 ? '...' : '');
        }
      }
      
      // Slide header
      pdf.setFontSize(16);
      pdf.setFont('helvetica', 'bold');
      pdf.setTextColor(41, 128, 185); // Blue
      
      const slideHeaderText = `${slideNumber}. ${slideTitle}`;
      const headerLines = pdf.splitTextToSize(slideHeaderText, usableWidth);
      
      headerLines.forEach(headerLine => {
        if (currentY > pageHeight - 20) {
          pdf.addPage();
          currentY = margin + 10;
        }
        pdf.text(headerLine, margin, currentY);
        currentY += lineHeight + 2;
      });
      
      currentY += 3; // Extra space after title
      
      // Slide content
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      pdf.setTextColor(0, 0, 0); // Black
      
      // Process content lines
      contentLines.forEach(line => {
        line = line.trim();
        if (!line) {
          currentY += lineHeight * 0.5; // Half line for empty lines
          return;
        }
        
        // Handle different line types
        let processedLine = line;
        let indent = 0;
        let isBold = false;
        
        // Bullet points
        if (line.match(/^[•\-*]\s*/)) {
          processedLine = '• ' + line.replace(/^[•\-*]\s*/, '');
          indent = 5;
        }
        // Sub-bullet points
        else if (line.match(/^\s+[•\-*]\s*/)) {
          processedLine = '  ◦ ' + line.replace(/^\s*[•\-*]\s*/, '');
          indent = 10;
        }
        // Headers or emphasis
        else if (line.match(/^[A-Z\s]{3,}:/) || line.includes('**')) {
          isBold = true;
          processedLine = line.replace(/\*\*/g, '');
        }
        
        // Set font style
        if (isBold) {
          pdf.setFont('helvetica', 'bold');
        } else {
          pdf.setFont('helvetica', 'normal');
        }
        
        // Split long lines to fit page width
        const availableWidth = usableWidth - indent;
        const splitLines = pdf.splitTextToSize(processedLine, availableWidth);
        
        splitLines.forEach((splitLine, lineIndex) => {
          // Check page break
          if (currentY > pageHeight - 25) {
            pdf.addPage();
            currentY = margin + 10;
          }
          
          pdf.text(splitLine, margin + indent, currentY);
          currentY += lineHeight;
        });
      });
      
      // Add space between slides
      currentY += lineHeight * 2;
      slideNumber++;
      
      // Add separator line between slides (except last)
      if (index < slides.length - 1) {
        pdf.setDrawColor(230, 230, 230);
        pdf.line(margin, currentY - lineHeight, pageWidth - margin, currentY - lineHeight);
        currentY += lineHeight;
      }
    });
    
    // Enhanced footer on each page
    const totalPages = pdf.internal.getNumberOfPages();
    for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
      pdf.setPage(pageNum);
      pdf.setFontSize(9);
      pdf.setTextColor(150, 150, 150);
      pdf.setFont('helvetica', 'italic');
      
      // Left footer: creation info
      pdf.text('Created with Cofoundr AI', margin, pageHeight - 8);
      
      // Right footer: page numbers
      const pageText = `Page ${pageNum} of ${totalPages}`;
      const pageWidth = pdf.internal.pageSize.getWidth();
      const textWidth = pdf.getTextWidth(pageText);
      pdf.text(pageText, pageWidth - margin - textWidth, pageHeight - 8);
    }
    
    return pdf;
  } catch (error) {
    console.error('Error generating PDF:', error);
    throw new Error(`Failed to generate PDF: ${error.message}`);
  }
};

export const downloadPDF = (pitchContent, filename = null) => {
  try {
    if (!pitchContent || typeof pitchContent !== 'string') {
      throw new Error('Invalid pitch content provided');
    }
    
    if (pitchContent.trim().length < 50) {
      throw new Error('Pitch content is too short to generate a meaningful PDF');
    }
    
    const pdf = generatePDF(pitchContent);
    const defaultFilename = `cofoundr-pitch-deck-${new Date().toISOString().split('T')[0]}-${Date.now()}.pdf`;
    
    // Enhanced filename sanitization
    const sanitizedFilename = (filename || defaultFilename)
      .replace(/[^\w\-_.]/g, '-') // Replace special chars with dash
      .replace(/--+/g, '-') // Replace multiple dashes with single
      .replace(/^-+|-+$/g, ''); // Remove leading/trailing dashes
    
    pdf.save(sanitizedFilename);
    
    // Log success for debugging
    console.log(`PDF downloaded successfully: ${sanitizedFilename}`);
    console.log(`Content length: ${pitchContent.length} characters`);
    console.log(`PDF pages: ${pdf.internal.getNumberOfPages()}`);
    
    return true;
  } catch (error) {
    console.error('Error downloading PDF:', error);
    console.error('Content preview:', pitchContent?.substring(0, 200) + '...');
    return false;
  }
};

// Enhanced PDF blob generation with error handling
export const generatePDFBlob = (pitchContent) => {
  try {
    if (!pitchContent || typeof pitchContent !== 'string') {
      throw new Error('Invalid pitch content provided for blob generation');
    }
    
    const pdf = generatePDF(pitchContent);
    const blob = pdf.output('blob');
    
    // Validate blob
    if (!blob || blob.size === 0) {
      throw new Error('Generated PDF blob is empty');
    }
    
    console.log(`PDF blob generated successfully: ${blob.size} bytes`);
    return blob;
  } catch (error) {
    console.error('Error generating PDF blob:', error);
    throw error;
  }
};

// New utility: Generate PDF as base64 string
export const generatePDFBase64 = (pitchContent) => {
  try {
    const pdf = generatePDF(pitchContent);
    return pdf.output('datauristring');
  } catch (error) {
    console.error('Error generating PDF base64:', error);
    throw error;
  }
};

// New utility: Validate content before PDF generation
export const validateContentForPDF = (pitchContent) => {
  const validation = {
    isValid: true,
    issues: [],
    suggestions: []
  };
  
  if (!pitchContent) {
    validation.isValid = false;
    validation.issues.push('No content provided');
    return validation;
  }
  
  if (typeof pitchContent !== 'string') {
    validation.isValid = false;
    validation.issues.push('Content must be a string');
    return validation;
  }
  
  const contentLength = pitchContent.trim().length;
  
  if (contentLength < 100) {
    validation.isValid = false;
    validation.issues.push('Content is too short (minimum 100 characters)');
    validation.suggestions.push('Generate a more detailed pitch deck');
  }
  
  if (contentLength > 50000) {
    validation.issues.push('Content may be very long, PDF generation might be slow');
    validation.suggestions.push('Consider using the detailed pitch option for better formatting');
  }
  
  // Check for common formatting issues
  if (!pitchContent.includes('SLIDE') && !pitchContent.match(/\d+\./)) {
    validation.issues.push('Content may not be properly structured into slides');
    validation.suggestions.push('Try regenerating the pitch deck for better structure');
  }
  
  return validation;
};

// New utility: Preview PDF content structure
export const previewPDFStructure = (pitchContent) => {
  try {
    const processText = (text) => {
      return text
        .replace(/╔═+╗/g, '')
        .replace(/║/g, '')
        .replace(/╚═+╝/g, '')
        .replace(/═+/g, '─'.repeat(50))
        .replace(/\*\*(.*?)\*\*/g, '$1')
        .replace(/\*(.*?)\*/g, '$1')
        .replace(/`(.*?)`/g, '$1')
        .replace(/#{1,6}\s*/g, '')
        .replace(/^\s*[-•*]\s*/gm, '• ')
        .replace(/^\s*\d+\.\s*/gm, '• ')
        .replace(/\n{3,}/g, '\n\n')
        .trim();
    };

    const parseContent = (content) => {
      const processed = processText(content);
      let slides = [];
      
      if (processed.includes('SLIDE')) {
        slides = processed.split(/(?:SLIDE\s*\d+:|SLIDE\s+\d+\s*[-:])/).filter(s => s.trim());
        if (slides.length > 0 && !slides[0].includes('SLIDE')) {
          slides = slides.slice(1);
        }
      } else if (processed.match(/^\d+\./m)) {
        slides = processed.split(/(?=^\d+\.)/m).filter(s => s.trim());
      } else if (processed.includes('─') || processed.includes('=')) {
        slides = processed.split(/(?=^.{10,}(?:─+|=+))/m).filter(s => s.trim());
      } else {
        const sections = processed.split(/\n\n+/).filter(s => s.trim());
        slides = [];
        let currentSlide = '';
        
        sections.forEach(section => {
          if (currentSlide.length + section.length < 800) {
            currentSlide += (currentSlide ? '\n\n' : '') + section;
          } else {
            if (currentSlide) slides.push(currentSlide);
            currentSlide = section;
          }
        });
        if (currentSlide) slides.push(currentSlide);
      }
      
      return slides.filter(slide => slide.trim().length > 20);
    };

    const slides = parseContent(pitchContent);
    
    return {
      totalSlides: slides.length,
      estimatedPages: Math.ceil(slides.length * 0.8) + 1, // Rough estimate
      contentLength: pitchContent.length,
      slides: slides.map((slide, index) => {
        const lines = slide.trim().split('\n').filter(line => line.trim());
        const title = lines.length > 0 ? lines[0].substring(0, 60) + '...' : `Slide ${index + 1}`;
        return {
          slideNumber: index + 1,
          title,
          contentLength: slide.length,
          lineCount: lines.length
        };
      })
    };
  } catch (error) {
    console.error('Error previewing PDF structure:', error);
    return {
      totalSlides: 0,
      estimatedPages: 1,
      contentLength: pitchContent?.length || 0,
      slides: [],
      error: error.message
    };
  }
};
